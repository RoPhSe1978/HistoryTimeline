function parseWikidataDate(dateStr) {
    if (!dateStr) return null;

    let isBC = false;
    let cleanStr = dateStr;

    // Handle prefixes
    if (cleanStr.startsWith('+')) {
        cleanStr = cleanStr.substring(1);
    } else if (cleanStr.startsWith('-')) {
        isBC = true;
        cleanStr = cleanStr.substring(1);
    }

    // Remove time part and Z
    cleanStr = cleanStr.split('T')[0];

    const parts = cleanStr.split('-');
    let year = parseInt(parts[0], 10);
    let month = parts.length > 1 ? parseInt(parts[1], 10) - 1 : 0; // 0-indexed
    let day = parts.length > 2 ? parseInt(parts[2], 10) : 1;

    // Handle invalid/unknown month/day (00)
    if (isNaN(month) || month < 0) month = 0;
    if (isNaN(day) || day < 1) day = 1;

    if (isBC) {
        year = -year;
    }

    // Create date and set full year explicitly to handle BC and 0-99 AD correctly
    const date = new Date(0);
    date.setFullYear(year, month, day);
    date.setHours(0, 0, 0, 0);

    if (isNaN(date.getTime())) {
        return null;
    }

    return date;
}

async function initTimeline() {
    try {
        // 1. Fetch the data generated by your Python script
        const response = await fetch('./data/historical_figures.json');
        if (!response.ok) throw new Error("Could not load JSON file. Make sure it exists!");
        const data = await response.json();

        const uniqueData = [];
        for (const person of data) {
            const isDuplicate = uniqueData.some(p =>
                p.name === person.name &&
                (p.birth === person.birth || p.death === person.death)
            );
            if (!isDuplicate) {
                uniqueData.push(person);
            }
        }

        const items = new vis.DataSet(uniqueData.map((person, index) => {
            const startClean = parseWikidataDate(person.birth);
            const endClean = parseWikidataDate(person.death);

            if (!startClean) return null;

            const content = person.wikipedia
                ? `<a href="${person.wikipedia}" target="_blank" style="color: inherit; text-decoration: none;">${person.name}</a>`
                : person.name;

            const imageHtml = person.image
                ? `<img src="${person.image}" width="100" class="timeline-portrait">`
                : '';

            return {
                id: index,
                content: content,
                start: startClean,
                end: endClean,
                title: `${imageHtml}<br><b>${person.name}</b><br>${person.description}`,
                // Keep raw strings for our contemporary overlap logic
                rawBirth: startClean,
                rawDeath: endClean ? endClean : new Date()
            };
        }).filter(item => item !== null));

        // 3. Define Timeline Options
        const container = document.getElementById('visualization');
        const options = {
            stack: true,
            horizontalScroll: true,
            zoomKey: 'ctrlKey',
            width: '100%',
            height: '100%',
            verticalScroll: true,
            zoomMin: 1000 * 60 * 60 * 24 * 30, // Minimum zoom: ~1 month
            zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000, // Maximum zoom: 10,000 years
            orientation: 'top',
            margin: { item: 10, axis: 5 }
        };

        // 4. Initialize the Timeline
        const timeline = new vis.Timeline(container, items, options);

        // 5. Contemporary Logic: Highlight overlaps on click
        timeline.on('select', function (properties) {
            if (properties.items.length === 0) {
                // Reset styles if clicking background
                items.forEach(item => items.update({ id: item.id, className: '' }));
                return;
            }

            const selectedId = properties.items[0];
            const selectedPerson = items.get(selectedId);

            const contemporaries = items.get({
                filter: function (item) {
                    // Logic: A is B's contemporary if (A.Start < B.End) AND (B.Start < A.End)
                    return (item.rawBirth < selectedPerson.rawDeath) &&
                        (selectedPerson.rawBirth < item.rawDeath);
                }
            });

            // Update classes: Highlight contemporaries, fade others
            const allItems = items.getIds();
            const updateArray = allItems.map(id => {
                const isContemporary = contemporaries.some(c => c.id === id);
                return {
                    id: id,
                    className: isContemporary ? 'highlight-contemporary' : 'fade-out'
                };
            });
            items.update(updateArray);
        });

    } catch (error) {
        console.error("Timeline Error:", error);
        document.getElementById('visualization').innerHTML = `<p style="color:red">Error: ${error.message}</p>`;
    }
}

initTimeline();